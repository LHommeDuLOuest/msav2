\documentclass[12pt, a4paper, openany]{report}

\usepackage[utf8]{inputenc} % un package
\usepackage[T1]{fontenc}      % un second package
\usepackage[francais,english]{babel}  % un troisième package
\usepackage{layout}
\usepackage[top=2.7cm, bottom=2.5cm, left=3.5cm, right=3cm]{geometry}
\usepackage{setspace}

\usepackage{color}
\usepackage{listings}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}


\usepackage{verbatim}
\usepackage{moreverb}
\usepackage{url}
\usepackage{pst-all}
\usepackage{eso-pic,graphicx}
\usepackage{caption} 
\usepackage[colorlinks=true,urlcolor=blue,linkcolor=red]{hyperref}
\usepackage{array}
\usepackage[toc,page]{appendix}
\usepackage[off]{auto-pst-pdf}
\usepackage{hyperref} % pour le sommaire table des matières
\AddThinSpaceBeforeFootnotes % à insérer si on utilise \usepackage[french]{babel}
\FrenchFootnotes % à insérer si on utilise \usepackage[french]{babel}
\usepackage{fancyhdr}
\pagestyle{headings}

\renewcommand{\appendixpagename}{Annexes}
\renewcommand{\appendixtocname}{Annexes}

\title{Memoire: Architecture Microservice}
\author{Lyes \bsc{Kherbiche}}
\date{2016-2017}



%new
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}


\begin{document}

\selectlanguage{francais}
\pagenumbering{arabic} 

\makeatletter
  \begin{titlepage}
  
  %\centering
   %   {\large \textsc{Université Paris Ouest Nanterre La Défense}}\\
    %  \textsc{SEGMI}\\
    %\vspace{1cm}
     % {\large\textbf{
      %  M2 Miage Classique Nanterre\\
       %\@date}}\\
    %\vfill
    %\vfill
     %  {\LARGE \textbf{\@title}} \\
    %\vspace{2em}
     %   {\large \@author} \\
      %  {\large Tuteur: Mr Fabrice Legon } \\
      
      
      
      
  \begin{sffamily}
   \begin{center}

    % Upper part of the page. The '~' is needed because \\
    % only works if a paragraph has started.
    \includegraphics[scale=0.5]{parisx.jpg}~\\[1.5cm]

    \textsc{\LARGE UFR SEGMI }\\[2cm]

    \textsc{\Large Mémoire Master II Classique MIAGE}\\[1.5cm]

    % Title
    \HRule \\[0.4cm]
    { \huge \bfseries Architecture Microservice\\[0.4cm] }

    \HRule \\[2cm]
    \includegraphics[scale=0.3]{fourmies.jpg}
    \\[2cm]

    % Author and supervisor
    \begin{minipage}{0.4\textwidth}
      \begin{flushleft} \large
         \textsc{Lyes Kherbiche}\\
        Promo 2016-2017\\
      \end{flushleft}
    \end{minipage}
    \begin{minipage}{0.4\textwidth}
      \begin{flushright} \large
        \emph{Tuteur :}  \textsc{M. Legond Fabrice}\\
        \emph{Responsable de la Formation:} \textsc{M. Pascal Poizat}
      \end{flushright}
    \end{minipage}

    \vfill

    % Bottom of the page
    {\large Juin 2017}

  \end{center}
  \end{sffamily}      
      
      
      
        
  \end{titlepage}
\makeatother



% *********************** Remerciements *****************
\chapter*{Remerciements}
\addcontentsline{toc}{chapter}{Remerciements}

  Je tiens à exprimer ma profonde gratitude à mon promoteur, monsieur LEGOND pour m'avoir encadré et guidé tout au long de l'année scolaire et mon mémoire, pour ses conseils judicieux et minutieusement prodigués.\\
  
  Aussi je tiens à lui reconnaître le temps précieux qu’il m'a consacré. Mes plus vifs remerciements vont aussi à tout le personnel d'ATOS Rennes plus particulièrement, monsieur Michel Vincent qui m’aide durant mon stage au sien de la société. \\
  
   Que les membres du jury trouvent ici mes remerciements les plus vifs pour avoir accepté d’honorer par leur jugement mon travail.\\
   
   Mes sincères sentiments vont à tous ceux qui, de près ou de loin, ont contribué à la réalisation des mes études supérieurs, en particulier ma chères familles et mes amis (es).\\
   
   
% *********************** Dédicaces *****************
\chapter*{Dédicaces}
\addcontentsline{toc}{chapter}{Dédicaces}
\begin{center}
\begin{Large} \textbf{À mes très chers parents} \end{Large}\\ 
\begin{Large} \textbf{À mes frères} \end{Large}\\
\begin{Large} \textbf{À toute ma famille} \end{Large}\\
\begin{Large} \textbf{À tous mes amis (es)} \end{Large} \\ 
\begin{Large} \textbf{À toute la promo 2016/2017} \end{Large}\\
\end{center}
\begin{flushright} \begin{Large} \textit{Lyes Kherbiche} \end{Large} \end{flushright}

%*********************** somaire **************
\tableofcontents
%*********************** listes des figures **************
\listoffigures


%*********************** Problématique **************
\chapter*{Problématique}
\addcontentsline{toc}{chapter}{Problématique}
   Depuis l’apparition de la nécessité de structurer le code, de l'époque des logiciels monolithiques, les besoins de l'informatique n'ont cessé de croître, l'informatique est divisée en plusieurs discipline, on trouve notamment l'architecture logicielle qui est peu enseignée, pour acquérir le savoir faire dans cette discipline il faut être sur le terrain, avoir embrasser toute autre discipline et cumuler de l’expérience pour être capable d'affronter ce domaine. 
   
   Les systèmes informatiques évoluent au fil du temps, ils ne sont jamais stagnés pour éviter d’être obsolètes car les besoins changent spontanément. La fin des années 90 l'architecture basée services a révolutionné l'industrie informatique, les entreprises adoptent ce nouveau style pour le passage à l’échelle, toucher une variété de domaine, allonger la durée de vie des systèmes et avoir un grand profit business. Plusieurs apparitions de solutions tiers pour aider à mettre en œuvre ce style, les systèmes commencent à grandir beaucoup d'efforts financiers, humains et techniques sont nécessaire pour maintenir cette élan, malheureusement beaucoup d'entreprises ont jeté l'éponge à cause de la complication et des coûts colossales, ce qui a poussé de nombreux projets vers l’échec. \\
   
   De nos jours, l'architecture microservice s'affiche pour résoudre certains problèmes des grandes applications encombrées en général et des architectures orientées services en particulier avec son angle de vision, en réduisant la complexité, le temps et la facilité de la mise en marche des applications modulaires et évolutives.



%*********************** INTRODUCTION **************
\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}
 
  Une des raisons de construire des logiciels est pour une utilité utilisateurs. Il est mieux de faire une application réussie et mal conçue que le contraire, ceci est vrai pour concrétiser l'idée à un artefact qui tourne puis avoir des feedback utilisateurs si la solution est utile avant de de se lancer à l’enrichir d'autres besoins utilisateurs. \\
  
  Une fois lancer dans le processus de l’enrichissement, il n'y a pas d'approche formelle à suivre, une multitude de manière de le faire, par contre le concept \textit{monolith first} \footnote{https://martinfowler.com/bliki/MonolithFirst.html} reste une des meilleures façon de procéder au début pour des applications simples.\cite{refbibMonoFirst}. 
  
  Avec le temps, on étend les fonctionnalités existantes et on ajoute d'autres, la quantité de code augmente, plus le temps passe plus les nouvelles fonctionnalités métier deviennent complexe et plus le projet est gros plus les interventions deviennent coûteuses et risquées, on se retrouve dans une impasse qui nous empêche d’évoluer notre système, dans ce cas le monolithe n'arrange pas les choses, d’où le besoin d'une architecture.\\
  
   la science de l’architecture logicielle facilite la modélisation des projets informatique, elle propose une organisation grossière du système comme une collection de pièces logicielles \cite{refbibFoundations}. L'approche micro-services permet une cadence de développement d'application beaucoup plus rapide
  
  
  Dans ce document, nous nous intéressons à l'architecture basée services notamment l'architecture micro-services (MSA) qui est née dans le web moderne, les micro-services sont interconnectés en utilisant une mince couche d'API simples, de manière générale nous abordons l'architecture logicielle puis les différentes caractéristiques des MSA.
                                                      
   

%*********************** Architecture Logicielle **************
\chapter{Architecture Logicielle}
 L’architecture c’est tout d’abord un art au même titre que la sculpture ou la musique. Il est le premier des arts majeurs et se définit comme l’expression de la culture. Ainsi quand on aborde l’architecture logicielle on devrait plutôt aborder d’ingénierie de construction logicielles.\\ \\
 % captures d’écrans 
 \begin{center}
   \includegraphics[scale=0.5]{exemple_archi_1.png}
   \captionof{figure}{\textit{Exemple d'architecture}}
   \label{fig1}
 \end{center}
 
 La figure au-dessus a une structure en couches avec des degrés d’implication différents. La partie de gauche interagie avec les utilisateurs, celle de droite traite et persiste des données et enfin la couche du milieu établie les liaisons  et véhicule l’information entre les deux première.\\
 
 Les logiciels d’entreprise classique souvent se représente en multi couches front/back office et décisionnel avec des sous-structure comme composite, fabrique, MVC (Model-View-Controller) implémenter à l’aide de framework, généralement reparties (déployés) sur un ou plusieurs serveurs qui vont communiquer entre elles pour assurer la scalabilité. Ce sont des décisions d’architecture logicielle qui ont leurs avantages et leurs inconvénients.\\
 
 Néanmoins cette structure n’est jamais stable au fil du temps, elle subit des changements car elle doit répondre aux nouveaux défis techniques et/ou aux nouveaux besoins des utilisateurs.\\
  
 En court, il y a une différence entre architecture logicielle et celle des bâtiments, si on prend un exemple, la tour Eiffel a toujours la structure et aura la même, tandis que celle d’un logiciel est fort envisageable qu’elle subira des changements dans le temps.
 
 \paragraph{Définition:}
 L’architecture répond plutôt à la question "Comment le faire" \cite{refbibArch} pour atteindre les objectifs et non pas "que doit doit faire le système" \cite{refbibArch} . D’une autre manière elle décrit comment il doit être construit d’une façon à répondre aux spécifications de l’analyse fonctionnelle.
 
 \section{Évolution de l'architecture}
  Avant les années 80, les architectures des systèmes informatiques étaient centralisées autour de calculateurs centraux (monolithique). Les terminaux étaient passifs, la productivité des développeurs était faible et la maintenance des applications était plus difficile.
  
  Les années 80 ont connu le développement du transactionnel et des bases de données et la nécessité de passé du monobloc vers un assemblage des entités de codes qui collaborent entre eux, ainsi une nouvelle architecture et langage à objet sont nés offrant une certaine granularité.
  
  Cependant, même si l’orienté objet offre une base saine pour le développement d’éléments réutilisables à fine ou à plus grosse granularité \cite{refbib1} , elle n’offre pas les notations adéquates pour la construction à plus large échelle. Les composants constituent des briques de construction à plus large échelle et sont vus comme le prolongement des objets \cite{refbib2}.
  
 A partir des années 90, l’émergence des réseaux à fait naître les application reparties sous formes de briques distribuées certaines offrent un service et les autres les consomment.

 % captures d’écrans 
   \begin{center}
     \includegraphics[scale=0.35]{evolution_archi_7.png}
     \captionof{figure}{\textit{Évolution de l'architecture}}
     \label{fig7}
   \end{center}
   
 \section{Pourquoi une architecture logicielle}
 Elle sert toutes les parties prenantes à cerner et comprendre le système, notamment les  développeurs à opérer sur des parties particulières du système, de prévoir à l’avance les endroits susceptible de modification ou d’extension et favorise la construction de composants réutilisables.
 
 \section{Utilité d’une architecture logicielle} \cite{refbib3}
 
  \begin{itemize}
      \item  Compréhension:
      Facilite la compréhension des grands systèmes complexes en donnant une vue de haut-niveau de leur structure et de leurs contraintes. 
      Les motivation des choix de conception sont ainsi mis en évidence
      \item  Réutilisation:
      Favorise l’identification des éléments réutilisables, parties de conception, composants, caractéristiques, fonctions ou données communes.
      \item  Construction:
      Fournit un plan de haut-niveau du développement et de l’intégration des modules en mettant en évidence les composants, les interactions et les dépendances. Elle doit permettre aux développeurs de travailler sur des parties individuelles du système en isolation.
      \item  Évolution:
      Met en évidence les points où un système peut être modifié et étendu. La séparation composant/connecteur facilite une implémentation du type "plug-and-play".
      \item  Analyse:
      Offre une base pour l’analyse plus approfondie de la conception du logiciel, analyse de la cohérence, test de conformité, analyse des dépendances.
      \item  Gestion:
      Contribue à la gestion générale du projet en permettant aux différentes personnes impliquées de voir comment les différents morceaux du casse-tête seront agencés. L’identification des dépendance entre composants permet d’identifier où les délais peuvent survenir et leur impact sur la planification générale.
  \end{itemize}
  
 \section{Styles d’architectures}
 Un Style architectural est un standard expliquant comment sera le système. Les systèmes ont généralement des ressemblances d’organisation en commun appelés styles architecturaux \cite{refbib4} \footnote{Garlan D. :Software architecture : perspectives on an emerging discipline. Prentice-Hall, Inc., Upper Saddle River, NJ, USA, 1996.}.\\
 
 Également, un système peut être combiner de plusieurs styles selon les besoins. Quelque des plus courants sont  le style client/serveur, le style Pipe\&Line (tuyau\&filtre), centrée sur les données, le style orienté objet et le style en couches.\\
 
 Les styles architecturaux ont des atouts qui aident à la compréhension pour créer, aussi pour apporter des changements sur le système et les réutiliser (Ne pas réinventer la roue).\\
 
  Citons quelques styles:
  \begin{itemize}
      \item  PipeLine \cite{refbibPipeLine}: ce style est utile pour les logiciels de traitement et de transformation de données par exemple les compilateurs, l'entité filtre reçoit des données en entrées, suivie d'un processus de traitement et de transformation puis redirige les résultats vers une sortie sur un ou plusieurs pipe. L'entité pipe joue le rôle de canal, il connecte deux filtres à travers duquel circulent les données et il est unidirectionnel (figure \ref{fig8}).
 
              % captures d’écrans 
              \begin{center}
                \includegraphics[scale=0.3]{pipe_line_8.png}
                \captionof{figure}{\textit{Style Pipeline}}
                \label{fig8}
              \end{center}
              
      \item  Centrée données: Elle comporte un composant central de type système de gestion de base de données et des composants périphériques, appelés clients, utilisent le composant central appelé serveur de données \cite{refbibCentreDonnee}.
      
      Il est utile dans le cas où des données sont partagées et fréquemment échangées entre les composants, ce style découple les données des traitements, exemple: Oracle Forms \footnote{$http://www.oracle.com/technetwork/developer-tools/forms/overview/index-098877.html$}.
      
      
      \item  couches: Avec ce style, le système est organisé en hiérarchie de couches qui exposent des interfaces bien définies et qui communiquent à travers des protocoles, chaque couche fait l'objet de client ou serveur ou les deux à la fois (figure \ref{fig9}).
             % captures d’écrans 
             \begin{center}
               \includegraphics[scale=0.3]{style_couche_9.png}
               \captionof{figure}{\textit{Style en couches}}
               \label{fig9}
             \end{center}
             
  \end{itemize}
  
  
%*********************** MSA **************
\chapter{Architecture Micro-service}
  Microservice Architecture (MSA) se distinguent d'autres architectures notamment l'architecture monolithique, objet, composant et même celles basées services.

    Les Microservice sont des services sous formes de petits composants autonomes qui communiquent ensemble pour réaliser des taches et ayant un faible couplage \cite{refbibFowler} .  \\

    Le MS pourrait être déployé comme un service isolé en tant que PAAS \footnote{Platform as a service}, cet isolement n'est pas gratuit bien que il rend notre système distribué simple et facile à concevoir en plus de ça, l'avantage des nouvelles technologies qui facilitent les formes de déploiement. Toutes les communications se font à travers le réseau, et pour réaliser un faible couplage il faut une bonne modélisation du système d'information et un bon choix des API.
  
    MSA possède des avantages par rapport aux types d'architecture qui partagent des API, des services et possèdent parfois une conception par modules, je cite quelques uns:  
                                                % itemes
                                                \begin{itemize}
                                                 \item utilisation des technologies hétérogènes .
                                                 \item Elasticité .
                                                 \item Scalabilité .
                                                 \item Facilité de déploiement .
                                                 \item Mise à jour optimale .
                                                \end{itemize}
   
   Dans ce qui suit, j'aborde  
                                                 % itemes
                                                \begin{itemize}
                                                 \item Les architectures basées services .
                                                 \item Les caractéristiques du service .
                                                 \item Les caractéristiques d'architecture .
                                                \end{itemize}
                                                      
 \section{Architectures basées services}
  MSA est une architecture basée service, ses composants mettent de l’importance à la notion de service pour implémenter des fonctionnalités métier et non métier, malgré les différences entre les architectures basées service, elles partagent certaines caractéristiques.\\
 
 Les architectures basées services ont une chose en commun c’est qu’elles sont distribuées, les services que leurs composants offrent, sont accessibles avec des appels distants par exemple, REST (Representational State Transfer), SOAP (Simple Object Access Protocol), AMQP (Advanced Message Queuing Protocol), JMS (Java Message Service), RMI (Remote Method Invocation). Les applications distribuées ont des avantages de scalabilité, de faible couplage et une maîtrise des processus de développement, de teste et de déploiement, les composants sont presque autonomes et facile à maintenir. Les architectures basées services sont connues d’être modulaire (exemple module maven), la modularité c’est d’encapsuler des parties de l’application en services autonomes chacun est développer, tester et déployer seul avec un minimum de dépendances des autres composants.\\
 
 Les applications distribuées ne sont pas sans exceptions, elles ont des défis à relever, on cite le bon choix du protocole d’accès distant, maintenir le contrat de service, disponibilité de service/gérer les pannes, sécuriser les appels distant, gestion des transactions, tous ça se sont quelques points à ne pas prendre à la légère pour créer des architectures basées service.\\
 
  \subsection{Contrat de service}
  Le contrat de service est un agrément entre le service distant et son consommateur qui est le client et on déclare dedans le format des données qui s’échangent entre eux, XML, Json, des objets java etc. Concevoir un contrat de service n’est pas une chose facile car il faut prévoir à l’avance sa maintenance et ses prochaines versions pour d’autres consommateurs. Exemple : Comme la figure \ref{fig2} au dessous le montre, on a un service qui expose à ses consommateur la météo, au début il était conçue de fournir la météo du jour même (Version 1), au fil du temps de nouveaux besoins d’autres utilisateurs apparaissent (Météo sur plusieurs jours), l’idée c’est de maintenir l’ancien service (car il possède encore des consommateurs) et de créer un un autre avec le même contrat et du coût on aura plusieurs versions du services.\\
  
  Cette approche de supporter les versions d’un contrat de service permet de développer et de déployer de nouvelles fonctionnalités et d’apporter des changements sans casser les contrats existants avec les consommateurs.\\
  
  % captures d’écrans 
   \begin{center}
     \includegraphics[scale=0.52]{version_contrat_2.png}
     \captionof{figure}{\textit{versions de contrat de service}}
     \label{fig2}
   \end{center}  
  
  \subsection{Réactivité \& Disponibilité de service}
   
   La figure \ref{fig3} illustre la différence entre disponibilité et réactivité de service, ces deux notions ont un rapport direct avec la capacité de communication entre le client et service distant.
   
   % captures d’écrans 
   \begin{center}
     \includegraphics[scale=0.4]{reactivite_disponibilite_service_3.png}
     \captionof{figure}{\textit{réactivité vs disponibilité de service}}
     \label{fig3}
   \end{center}
   
   % itemes
   \begin{itemize}
      \item La disponibilité: fait référence à l’établissement de la connexion et la capacité de répondre au requêtes du client vers le service distant \cite{refbibDispo}.
      \item La réactivité \footnote{https://hal.inria.fr/inria-00177149/document}: fait référence à la réception de la réponse par le demandeur du service dans des délais acceptables. 
  \end{itemize}
  
  À défaut de ces conditions la requête ne sera pas accomplie.
  
  \subsection{Sécurité}
  Il est très important de sécuriser les accès distants, certains services exposés doivent être protéger, en d’autres termes le demandeur doit être authentifier et autoriser.
  % itemes
  \begin{itemize}
      \item authentification\footnote{https://fr.wikipedia.org/wiki/Authentification}: désigne le processus visant à confirmer qu'un commettant est bien légitime pour accéder au système.
      \item autorisation\footnote{https://fr.wikipedia.org/wiki/Autorisation}: est la fonction spécifiant les droits d'accès vers les ressources liées à la sécurité de l'information et la sécurité des systèmes d'information en général et au contrôle d'accès en particulier.
  \end{itemize}
  Les micro-services sont indépendants, en partant de ce concept et laissant la gestion de la sécurité à un service à part, on obtient un fort couplage et une dépendance pour chaque service qu’on doit protéger, autrement dans le cas ou on fabrique des services qui gèrent leurs sécurité on aura énormément de redondance, avec les MSA la sécurité devient un défi, les solutions qui semblent être correcte c’est de déléguer l’authentification à un service dédié et manœuvrer les autorisations au sein même du service.
  
  \subsection{Gestion de données et Transactions}
  Les entreprises préfèrent avoir des bases de données centralisées non fédérées, une base par contexte applicatif car c’est plus avantageux et plus facile à gérer.

  Avec les MSA Chaque service gère sa propre base de donnée (illustration figure \ref{fig25}), une décentralisation du schéma physique et logique de données.

  La décentralisation des données entre les micro-services à des implications sur la cohérence des données,  pour palier à cette difficulté , les MS (même les différentes autres archi) ont recours à des mises à jour entre les différentes ressources de données  qui sont traitées à l’aide des transactions dites distribuées \cite{refbibFowler}.  \\
  
   % captures d’écrans 
   \begin{center}
     %\includegraphics[scale=0.3]{decentra_db_25.png}
     \includegraphics[width=\textwidth, height=5cm]{decentra_db_25.png}
     \captionof{figure}{\textit{Décentralisation des bases de données}}
     \label{fig25}
   \end{center}
  
  Dans le contexte de micro services la mise en œuvre de mécanismes relatifs aux transactions constitue souvent une difficulté, cela s’explique par le faite que souvent les transactions se basent sur les principes suivants (ACID) \footnote{$https://vladmihalcea.com/2014/01/05/a-beginners-guide-to-acid-and-database-transactions/$} \cite{refbibAcid} : 
  
   %itemize
   \begin{itemize}
      \item Atomicité : Un ensemble d’opérations (souvent lecture/écriture) constitue une seule opération qu’on exécute entièrement ou pas du tout. 
      \item Consistance : (Cohérence) Cela implique une cohérence dans les données mais aussi le non échec de tout opération voir sous opération relative aux données (exemple échec de l’exécution d’un trigger de Base de données).
      \item Isolation : On arrive à gérer souvent cela grâce aux mécanismes d’accès concurrents tel que les locks.
      \item Durabilité : est le faite de pouvoir s’assurer qu’au cas du crash d’un système par exemple qu’on puisse rejouer toutes les transactions non achevés. 
   \end{itemize}
   
   Les quatre principes énoncés précédemment deviennent presque un challenge dans le cadre micro-services, les transactions distribuées sont incontestablement difficiles à mettre en œuvre, car une transaction fera plusieurs appels distants à différents ressources de données des micro services, de ce faite les transactions dans le cadre de micro-services à un moment la cohérence est partielle, les données seront cohérentes qu’après un laps de temps après  la transaction.
   
     Pour conclure sur ce point on peut dire que dans le cadre des transactions micro services il faut sortir du principe classique ACID et prendre en compte un laps de temps pour la cohérence, ce principe est une alternative, c'est les transactions BASE \footnote{$http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/$} \cite{refbibBase}: 
     %itemize
   \begin{itemize}
      \item Basic Availability: La base de données semble fonctionner la plupart du temps, le système est disponible, mais pas nécessairement toutes ressources à un moment donné.
      \item Soft-state: L'état du système pourrait changer avec le temps, de sorte que, même en période sans activités, il se peut qu'il y ait des changements en raison de la cohérence partielles, donc l'état du système est toujours doux.
      \item Eventual consistency: Après un certain laps de temps, toutes les sources de données sont cohérentes, mais à tout moment, cela pourrait ne pas être le cas.
   \end{itemize} 
   
 
 \section{Caractéristiques du service}
  \subsection{Classification de service}
   La classification dans l’ensemble de l’architecture s’attribue au type/rôle du service d’un coté et le domaine métier de l’autre.
   
   On entend par type l’implantation fonctionnelle ou non fonctionnelle et par métier (business) le cœur, le but, la finalité du service, exemple faire une réservation, insertion d'un client.\\
   
   En analogie aux SOA comme le montre la figure \ref{fig4}, on trouve une variété de rôle/type de service, la pattern d'archi SOA exige une définition de quatre types/rôles: Service métier, entreprise, application et à la fin le service infrastructure.
   %itemize
   \begin{itemize}
      \item  Service métier: est quelque chose d’abstrait il a des entrées et sorties mais il implante pas le cœur métier car il porte juste le nom du service , son rôle par exemple la vérification/validation des données d’entré (primitifs, XML, etc) et il aiguille vers le service d'entreprise adéquat.
      \item  Service entreprise: est partagé par la majorité de l'organisation, c'est à ce niveau que se fait l'implantation effectif des fonctionnalités définies dans service métier, il utilise la brique middleware comme intermédiaire entre les service métier abstrait et son relatif effectif.
      \item  Service application:c'est comme le service entreprise on trouve l'implantation fonctionnelle à la différence il n'est pas partagé en d'autre termes il contient des fonctions spécifiques.
      \item  Service infrastructure: il englobe le non fonctionnel, exemple Log, sécurité, performances ...  
   \end{itemize}
    
   % captures d’écrans 
   \begin{center}
     %\includegraphics[scale=0.35]{classif_soa_4.png}
     \includegraphics[width=13cm, height=6.8cm]{classif_soa_4.png}
     \captionof{figure}{\textit{Classification Soa}}
     \label{fig4}
   \end{center}
   
   \paragraph{Middleware:} (intergiciel) est un programme qui s'insère entre deux applications et qui va permettre de faire communiquer des machines entre elles, indépendamment de la nature du processeur, du système d'exploitation, voire du langage \cite{refbibMiddle}. \\
   
   Msa est pauvre coté classification, on trouve que deux types/rôles de service comme le montre la figure \ref{fig5}, on aperçoit le service fonctionnel qui encapsule toute la logique métier d'un seul service en une seule brique non partagé et l'infrastructure qui implémente le non fonctionnel (sécurité, logging,..) qui est commun pour les autres services.

   % captures d’écrans 
   \begin{center}
     %\includegraphics[scale=0.5]{classif_msa_5.png}
     \includegraphics[width=12cm, height=5.5cm]{classif_msa_5.png}
     \captionof{figure}{\textit{Classification microservice}}
     \label{fig5}
   \end{center}
   
  
  \subsection{Structure Organisationnelle} %avant -> détenteur de service
   
   La Structure Organisationnelle des blouses bleu traditionnelle est composée et répartie par spécialité, on trouve des équipes de développement frontend, backend, d'intégration, de testeurs, d'administrateurs de base de données, chacune occupe son espace, cela peut fonctionner et donner ses fruits, néanmoins cette organisation appliquer pour une architecture MS peut avérer mal adéquate et des problèmes vite fais apparaissent, comme qui sera responsable d'un service donné parmi cette structure par équipes, en d'autre termes les MS ont besoins d'un détenteur de service, les ressources humaines ou groupe de l’organisation qui sont responsable de créer et maintenir le service.\\
   
   On a vu au paragraphe précédant la limitation de la classification des MSA(infra, fonctionnel), cela emmène que pour coder ou maintenir un MS il n'est pas nécessaire d'avoir une multitude de groupe de développeur, un groupe pluridisciplinaires est largement suffisant du coût ce service leur appartient et seront responsable du service du début à la fin.
   
    % captures d’écrans 
   \begin{center}
     %\includegraphics[scale=0.4]{detenteur_service_msa_6.png}
     \includegraphics[width=11cm, height=5cm]{detenteur_service_msa_6.png}
     \captionof{figure}{\textit{Détenteur du service en msa}}
     \label{fig6}
   \end{center}
   
   À l'opposé des MSA la ou une variété de classification, ou chaque couche de service appartient à un groupe, il faut en plus de ça l'effort de coordination entre eux, mais avec les MSA y a aucun besoin de coordination et si il est nécessaire il se fait rapidement à travers d'une même équipe détenteur du service.
   
   Cette différence de la quantité de coordination se répercute directement sur le temps et l'effort nécessaire du développement, build/déploiement, testes et la maintenance du service.
   
   \subsection{Granularité du service}
   Il existe deux concepts clé beaucoup utilisés dans le contexte orienté objet qui permettent de faire des services de qualité issue de GRASP \footnote{General responsibility assignment software patterns} qui caractérise les Msa.
   %itemize
   \begin{itemize}
      \item Forte Cohésion: Favorise la compréhension, la maintenance et la réutilisation des classes qui devront avoir des responsabilités cohérentes spécifique non variées. Une classe est dite faiblement cohésive si elle effectue diverses taches.\cite{refbib5}
      \item Faible Couplage: Le couplage est le niveau de dépendance et d’interaction entre les classes (Composant), on parle de faible couplage lorsque les composants ont peu d’interaction entre eux.\cite{refbib5}
  \end{itemize}
  
  Un MS est petit à fine granularité et expose une fonction qui accomplie une seule tache, implémenté avec un ou deux modules, contrairement aux composants des architectures monolithiques ou distribuées qui ont tendance à grandir offrant une variété de fonctions et de taches parfois implémenter en sous systèmes.
  
  La granularité touche la performance et les transactions. Un service avec une granularité mal conçue, pour accomplir une requête utilisateur consommera un coût de transport élevé entre les appels distant car il aura besoin de relayer et déléguer la tache aux services plus profond. 
  
    % captures d’écrans 
   \begin{center}
     \includegraphics[scale=0.38]{impact_perform_10.png}
     \captionof{figure}{\textit{Impacte sur les performances}}
     \label{fig10}
   \end{center}
   
   La figure \ref{fig10} au dessus illustre un exemple de très fine granularité, pour accomplir une requête utilisateur il faut un temps de transport entre appels distants sans compter le temps de processing qui est T1+T2+...+Tn+T'1+...+T'n (n étant le nombre de service de transite) ce qui est coûteux, la solution consiste à fusionner ces services on un seul pour réduire le coût de transport en T1+T'1.\\
   
    % captures d’écrans 
   \begin{center}
     \includegraphics[scale=0.35]{impact_transac_11.png}
     \captionof{figure}{\textit{Impacte sur les transactions 1}}
     \label{fig11}
   \end{center}
   
   Les transactions sont aussi touchées, comme l'illustre la figure \ref{fig11} si il y a une très fine granularité on aura des mises à jour indépendantes dans la base de données du coup ça sera difficile de coordonner le service en utilisant une seule transaction, par contre en fusionnant en un seul service distant, on peut gérer les requêtes engendrer par des mises à jour transactionnelles comme le montre la figure \ref{fig12}.
   
    % captures d’écrans 
   \begin{center}
     \includegraphics[scale=0.33]{impact_transac_12.png}
     \captionof{figure}{\textit{Impacte sur les transactions 2}}
     \label{fig12}
   \end{center}
   
 \section{Caractéristiques d'architecture}
 
  Dans cette partie on va aborder les briques (composants) architecturales, comment communiquent ils, les composants partagés, et leur accessibilités à partir des services distants ou par les consommateurs.\\
  
   \subsection{Composants partagés}
    Pour illustrer ça, assumons au départ qu'on a devant nous un système de réservation répartie sur trois sous-système: gestion des clients, des réservations et de l'entrepôt de données, figure \ref{fig13}, chacun à sa propre définition de la notion 'réservation', pour une requête client signifie une reproduction de la réservation dans différents sous-système sans compter le travail de coordination.

     % captures d’écrans 
   \begin{center}
     \includegraphics[scale=0.3]{compos_partag1_13.png}
     \captionof{figure}{\textit{Redondance de composants}}
     \label{fig13}
   \end{center}
    
    Cette duplication pousse les architectes à factoriser toute les fonctionnalités qui se ressemble en un seul endroit comme composant partagé du système, si on revient vers notre exemple, on aura un seul travail de 'réservation' partagé entre les trois sous-système, figure \ref{fig14}.
        
   % captures d’écrans 
   \begin{center}
     \includegraphics[scale=0.3]{compos_paratag2_14.png}
     \captionof{figure}{\textit{Composants partagés}}
     \label{fig14}
   \end{center}
    
   Les composants partagés est une solution pour factoriser le code des fonctionnalités métier mais, tendent à grandir au fil du temps, ne résous pas la réplication de données, crée un fort couplage et trop de dépendance et ça devient vulnérable aux changements.\\
   
   Les MSA adopte une philosophie qui dit 'partager le moins possible' \cite{refbib6} , avec une encapsulation à la fois des traitements et des données en exposant une interface.\\
   
   Au cours du développement, il apparaît toujours une duplication de code qu'on devra factoriser même avec les MSA comme le service infrastructure, mais contrairement aux autres architectures basées services qui favorisent le maximum de composants partagés, les MSA essaient de partager le minimum possible. Il existe des façons dites brusque pour apparier au partage de composant, c'est la duplication de code des fonctionnalités communes dans chaque MS.\\
   
   
   \subsection{Orchestration et Chorégraphie}
   
    D'abord pour expliquer ces deux notions, on penche au monde de la culture ou je fais référence à la musique et la danse, puis on verra l'impacte de ces notions sur les MSA.\\
    
    Pour faire simple, dans le monde musicale avec un groupe de musiciens (orchestre) qui jouent avec différents instruments, on trouve cet individu avec une baguette à la main qui dirige ou orchestre l'ensemble, afin de produire une musique, c'est de la même façon pour la coordination des services (voir figure \ref{fig15}).\\
     
    J'attribue l'orchestration à la coordination des services à travers un médiateur centralisé pour but d'accomplir un travail métier. \\
     
    % captures d’écrans 
    \begin{center}
      \includegraphics[scale=0.3]{service_orchestra_15.png}
      \captionof{figure}{\textit{Orchestration des services}}
      \label{fig15}
    \end{center}
    
    Laissant le monde musicale et partant vers le domaine de la danse, sur une scène on observe un groupe de danseurs qui bougent et dansent ou chaque individu est synchronisé avec un autre sans qu'il y a un médiateur qui les dirigent.\\
    
    La chorégraphie c'est cet enchaînement et la communication qui se passe entre les services, ou la séquence d'appel d'un service à un autre pour accomplir une tache sans qu'il y est un orchestrateur qui dirige au milieu (voir figure \ref{fig16}).
    
    % captures d’écrans 
    \begin{center}
      \includegraphics[scale=0.3]{service_choreg_16.png}
      \captionof{figure}{\textit{Chorégraphie des services}}
      \label{fig16}
    \end{center}
    
    Les MSA se basent plutôt sur la chorégraphie que sur l'orchestration cela est due à différentes raisons. La plus importante c'est l'absence du médiateur centrale pour orchestrer, le manque de profondeur dans l'architecture MS aussi joue un rôle comme le montre la figure \ref{fig17}, on constate deux parties essentielles le service lui même et la couche API.\\
    
    NB: sur la figure \ref{fig17} j'ai pas mis en évidence la modélisation non fonctionnelle des service effectuant des taches d’infrastructure. \\
    
    % captures d’écrans 
    \begin{center}
      \includegraphics[scale=0.3]{topologie_msa_17.png}
      \captionof{figure}{\textit{Topologie Msa}}
      \label{fig17}
    \end{center}
    
    Les MSA possèdent un minimum de chorégraphie, on trouve pas non plus une longues séquence d'appel d'un service à un autre due au faible couplage/interaction entre services et sa politique 'partager le moins possible' (sauf à l'exception avec l'infrastructure), et si vous sentez à un certain moment le besoin de chorégraphier vos services c'est peut être dû à la très fine granularité de vos fonctionnalités.\\
     
    Trop de chorégraphie engendre un couplage élevé et ça entraîne une mauvaise performance due au temps nécessaire de transport de l'information entre les remotes. 
    
    L'issue pour les longues chorégraphies avec les MSA c'est d'incorporer la fine granularité en grosse granularité. Si une fonctionnalité à fine granularité est partagée par une multitude de service se manifeste, alors soit on l'isole en un MS à part, ou de l'annexer dans chaque MS qui a besoin de cette fonctionnalité en fermant les yeux sur la duplication de code.
   
   La figure \ref{fig18} suivante illustre une modélisation du regroupement de deux service à fine granularité en un service.\\
   
    % captures d’écrans 
    \begin{center}
      \includegraphics[scale=0.3]{fusion_service_18.png}
      \captionof{figure}{\textit{Exemple de fusion de service}}
      \label{fig18}
    \end{center}
    
    
   \subsection{Communication} % avant -> Couche API
   
    La couche API qui apparaît sur la classification des MSA (figure \ref{fig5}) remplace l'intergiciel (bus) des architectures basées service que les MSA n’implémente pas souvent, cette couche est un service d’accès façade situé entre le service client et le service métier, elle forme une couche d'abstraction et isole, découple le consommateur du micro-service, de cette façon la localisation du MS est ignorée par le client, permet aussi de préserver le service client des changements que le MS subira, du coup on obtient un système qui évolue au fil du temps sans impacter les consommateurs.
    
    Prenons un exemple, supposons qu'on a un service métier à grosse granularité qu'on veut scinder en deux services fins pour des raisons de monté en charge, on est capable de porter des modifications de code du service sans que le client le sache en fractionnant son unique requête vers les deux service engendrer à travers la couche API.\\
    
    Bien que les micro-services peuvent implanter une variété de protocole pour les appels distants et la communication entre eux, le protocole REST est le plus répandu.
    
    Pour réaliser la reconnaissance des services entre eux, chaque service aura besoin de localiser les services dont il a besoin, et mettre en place un mécanisme de loadbalancer comme point d'entrée pour gérer la monté en charge et rediriger les requêtes.
    
    Néanmoins, cette solution utilisant une couche API REST avec un loadbalanging semble correcte au cas on a une poignée de service, au cas contraire ça devient difficile de gérer la communication REST à plusieurs raisons, si les services changent de localisation alors une reconfiguration sera nécessaire, la multitude de service engendre l'effet spaghetti, REST est asynchrone. Tout cela induit une convergence vers la lourdeur du système. \\
     
    En s’appuyant sur la couche abstraite API, les MSA perdent certains moyens architecturaux d'entreprise tel que service de messagerie amélioré (EMS Enhanced Messaging Service) et la conversion de message, par contre elles peuvent adopter le service de nommage (annuaire) et la conversion de protocole à une condition.\\
    
    % captures d’écrans 
    \begin{center}
      \includegraphics[scale=0.3]{convers_protoco_19.png}
      \captionof{figure}{\textit{Conversion de protocole}}
      \label{fig19}
    \end{center}
    
    La conversion de protocole c'est quand le client effectue un  appel distant avec l'utilisation d'un protocole que le service métier n'attend pas, exemple figure \ref{fig19}. Les MS supportent de multiple types de protocoles,  mais pour faire mieux c'est d'essayer d'utiliser le même protocole. \\
    
    % captures d’écrans 
    \begin{center}
      \includegraphics[scale=0.3]{annuaire_20.png}
      \captionof{figure}{\textit{Utilisation du service de nommage}}
      \label{fig20}
    \end{center}
    
    Le service de nommage (annuaire) permet de localiser et d'obtenir un réfèrent du service cible et de l'invoquer (figure \ref{fig20}), Les MS peut utiliser ce paradigme à travers la couche API, ça reste déconseillé car il crée une dépendance de médiateur centralisé.  \\ \\
    
    % captures d’écrans 
    \begin{center}
      \includegraphics[scale=0.3]{convers_msg_21.png}
      \captionof{figure}{\textit{Conversion de message}}
      \label{fig21}
    \end{center}   
    
    La conversion de message que les MSA n'adoptent pas, c'est la conversion du format des données transmis entre le consommateur et le service métier, la figure \ref{fig21} montre un client faisant appel au service cible en transmettant des données au format JSON alors que le service a besoin des données au format XML.\\
    
   % Bien que les microservices peuvent implanter une variété de protocole pour les appels distants, le protocole REST à travers la couche API est le plus répandu, cette simplicité et homogénéité les distinguent d'autres architectures.%
   
   L'autre moyen d'intercommunication c'est par bus de messages (figure \ref{fig26}), on a abordé précédemment  que la communication par service REST n'est efficace que si leur nombre est raisonnable avec un faible couplage, avec cette alternative les MS n'ont plus besoin de se localiser.
   
    % captures d’écrans 
    \begin{center}
      \includegraphics[scale=0.3]{intercomm_msg_26.png}
      \captionof{figure}{\textit{Intercommunication par messages}}
      \label{fig26}
    \end{center} 
   
    L'intercommunication par message fait des services des consommateurs/consommés, les échanges deviennent asynchrone, de ce fait le système sera fluide et facilement scalable, néanmoins une dépendance vers l'infrastructure (bus) n'est pas évitable. 
   
     
%******************Chapitre building MS**************************** 

  
  
% *********************** Conclusion *****************
\chapter*{Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}
 
 Prendre une décision d'architecture à appliquer pour créer ou migrer un logiciel est une tache pas facile, car choisir un style d'architecture pour un système d'information a des effets sur la structure, le cycle de vie du projet et l'organisation de l'entreprise.\\

  L'invention de l'architecture micro-service n'est pas un hasard, en effet c'est pour résoudre les obstacles des architectures antérieures notamment la complexité et l'innovation. La solution de base apporter par les MS est de découper en petit projet indépendant, limiter leur taille avec une petite équipe pluridisciplinaire pour chacun des projets.\\
  
  Découper le domaine métier avec un concept fondamental \textit{partager aussi peu que possible} \cite{refbib6}, pour cela la compréhension du métier est primordiale. La manière de découper n'est pas formelle, il arrive parfois qu'on se trompe en prenant de mauvaise décisions, pour limiter leurs impacts, il faut éviter de fractionner toute à la fois, en commençant de sortir quelques contextes délimités en quelques micro-services indépendants, de cette façon si on se trompe, seulement une petite partie du système qui sera toucher.\\
  
  
%********************************* LES ANNEXES ********************
%\appendix
\begin{appendices}
 
  \chapter{Micro-service avec spring boot}
  
  Je montre ici la simplicité de créer des micro-services en utilisant le framework Spring Boot.\\
  
  Pour commencer assurer vous d'avoir installer l'outil de build apache Maven ($https://maven.apache.org/download.cgi$)et le JDK-8 d'oracle et bien les configurer dans la variables d’environnement de votre système.\\
  
  La première étape on télécharge un archetype maven avec lequel on va travailler, pour faire ouvrer votre invité de commande ou terminal et taper la commande \textit{mvn archetype:generate -DgroupId=org.apache.maven.archetypes -DartifactId=maven-archetype-quickstart} . \\ 
  
  Cette commande va nous générer un simple projet Java, ensuite on modifie le \textit{pom.xml} qui se trouve à la racine du projet et on ajoute la dépendance Spring boot starter comme suit:
  
\begin{lstlisting}
    <groupId>fr.uparisx.miage</groupId>
    <artifactId>ms-miage</artifactId>
    <version>1.0</version>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>1.5.2.RELEASE</version>
    </parent>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    </dependencies>
    <properties>
        <java.version>1.8</java.version>
    </properties>
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
\end{lstlisting}
 
 Avant d'aller plus loin on va s'assurer que notre projet est bien configuré, pour cela on va lancer la commande  \textit{mvn clean install} qui va permettre de compiler, packager puis installer notre artefact dans notre dépôt local maven.
 
 Maintenant, on code nos classes java, notre classe principale \textit{ExempleMsApp.java} :
 
\begin{lstlisting}
package fr.uparisx.miage.app;

import java.util.Arrays;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;

/**
 * 
 * @author L Kherbiche
 *
 */
@SpringBootApplication
public class ExempleMsApp {

    public static void main(String[] args) {
        SpringApplication.run(ExempleMsApp.class, args);
    }
}
\end{lstlisting}

 Puis notre REST Controller \textit{MsController.java} qui va nous fournir une chaîne de caractères.
\begin{lstlisting}
package fr.uparisx.miage.ctrl;

import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.RequestMapping;
/**
 * 
 * @author L Kherbiche
 *
 */
@RestController
public class HelloController {

    @RequestMapping("/")
    public String getSomeCaract() {
        return "une chaine de caracteres";
    }
}
\end{lstlisting}
 
 Il nous reste plus qu'a exécuter notre service \textit{getSomeCaract} en utilisant la commande suivante 
 \textit{mvn clean install \&\& java -jar target/ms-miage-1.0.jar}
 
 Pour voir si ça fonctionne on tape la commande \textit{curl localhost:8080} pour obtenir notre chaîne de caractères 
\textit{une chaine de caracteres}.


\chapter{Construction des microservices} % changer le nom du chapitre -> deploiement des MS
 
 \section{Intégration continue des microservices}
 
   La question à laquelle on va répondre ici, c'est comment on va builder chaque micro-service individuellement et ceux à qui on a porté des modifications de code, pour les déployer sans impacter le reste. \\
  
  De multiples choix de build existent certains sont mieux que les autres, le plus simple consiste à utiliser un seul dépôt de codes, un seul serveur d'IC et un seul build, pour construire tous nos services (figure \ref{fig22}), avec cette maniéré de procéder, si un commit/push d'une ligne de code se fait sur un seul MS, ça provoque le cycle de build (vérification, compilation, testes ...) pour tout les autres, cela prend plus temps qui lui faut car hormis le MS concerné le reste du dépôt est construit inutilement, de plus si il est suivit d'un échec de build toute l’équipe sera pénaliser et ne pourra plus porter d'autre changements jusqu'à ce que la correction soit porter pour continuer. Cette technique de build reste à éviter.\\
  
  % captures d’écrans 
  \begin{center}
    \includegraphics[scale=0.3]{itegra_conti_1_22.png}
    \captionof{figure}{\textit{Build en monobloc}}
    \label{fig22}
  \end{center} 
  
  La démarche de build la plus adéquate pour les micro-services c'est d'avoir une configuration de l’environnement de l'IC permettant de lancer un build par micro-service. Comme le montre la figure \ref{fig23}, chaque MS est construit dans son propre cycle de build séparément du reste.
  
   % captures d’écrans 
  \begin{center}
    \includegraphics[scale=0.32]{itegra_conti_2_23.png}
    \captionof{figure}{\textit{Un build par micro-service}}
    \label{fig23}
  \end{center} 
 
 Partir du code jusqu'à la prod le MS passe par étapes, le cycle de build (vérification, compilation, testes unitaire...), testes fonctionnels, testes de performances, préproduction puis il passe en production (figure \ref{fig24}), ces étapes font référence à la production continue. \\
 
   % captures d’écrans 
  \begin{center}
    \includegraphics[scale=0.35]{etape_prod_24.png}
    \captionof{figure}{\textit{Modélisation des étapes de production}}
    \label{fig24}
  \end{center} 



\chapter{REST}
  Representational State Transfer  est un style d'architecture pour les systèmes hypermédia distribués, créé par Roy Fielding en 2000 dans le chapitre 5 de sa thèse de doctorat \cite{refbibrest} . Il est devenue très populaire car il offre une alternative des services web SOAP.
  \paragraph{Principes de REST:}
  \begin{itemize}
    \item Interface uniforme: le cœur de REST c'est les ressources, chaque ressource est identifié par une URI Uniform Resource Identifier, les ressources sont séparer de leur représentation, en général avec REST les ressources sont rendues aux client en utilisant un format de données XML ou JSON. En plus la description de la représentation de la ressource encapsule son auto-description, et les interactions entre client et service s'effectue à travers un hypermédia.
    \item Client serveur: avec REST le serveur et le client sont séparés et ont des préoccupations séparé, Cela permet aux deux d'évoluer indépendamment, permet de réduire la complexité et d'offrir de bonne performances. 
    
    \item Stateless: y a pas de sauvegarde de l’état du client au niveau serveur, toute les informations nécessaire pour exécuter une opération sont encapsuler dans la requête.
    
    \item Mise en cache: le serveur peut de gérer les mises en cache en indiquant dans chaque réponse la possibilité de la conserver en cache ou pas incluant des informations concernant sa date de validité et sa date de création. 
      
    \item Système par couche: Étant donné le style de communication entre le client et le serveur, les clients ne connaissent pas spécifiquement le serveur  avec lequel ils interagissent. Ce découplage permet l'introduction de serveurs intermédiaires qui peuvent, par exemple, gérer la sécurité, la monté en charge, la scalabilité .
    
    \item Code on demand: Même s'il fait partie de l'architecture REST, ce principe est facultatif. Les serveurs peuvent transférer du code aux clients pour exécution, cela permet d’alléger le serveur coté traitement.

  \end{itemize}
  
  Pour qu'un service soit considéré comme RESTful, il doit respecter les principes précédents.

\end{appendices}
 
%Bibliographie 
\bibliographystyle{alpha}
\bibliography{biblio}
    
\end{document}